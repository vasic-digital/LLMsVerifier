// Package auth provides LDAP integration for enterprise authentication
package auth

import (
	"crypto/tls"
	"fmt"
	"strings"

	"github.com/go-ldap/ldap/v3"
)

// LDAPConfig holds LDAP configuration
type LDAPConfig struct {
	Host         string   `yaml:"host"`
	Port         int      `yaml:"port"`
	BaseDN       string   `yaml:"base_dn"`
	BindDN       string   `yaml:"bind_dn"`
	BindPassword string   `yaml:"bind_password"`
	UserFilter   string   `yaml:"user_filter"`
	GroupFilter  string   `yaml:"group_filter"`
	Attributes   []string `yaml:"attributes"`
	TLS          bool     `yaml:"tls"`
	StartTLS     bool     `yaml:"start_tls"`
}

// LDAPManager handles LDAP operations
type LDAPManager struct {
	config *LDAPConfig
}

// NewLDAPManager creates a new LDAP manager
func NewLDAPManager(config *LDAPConfig) (*LDAPManager, error) {
	return &LDAPManager{
		config: config,
	}, nil
}

// Authenticate performs LDAP authentication
func (lm *LDAPManager) Authenticate(username, password string) (*Client, error) {
	if password == "" {
		return nil, fmt.Errorf("password cannot be empty")
	}

	// Connect to LDAP server
	conn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP: %w", err)
	}
	defer conn.Close()

	// First, bind as the search user to find the user's DN
	searchRequest := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.UserFilter, username),
		lm.config.Attributes,
		nil,
	)

	sr, err := conn.Search(searchRequest)
	if err != nil {
		return nil, fmt.Errorf("LDAP search failed: %w", err)
	}

	if len(sr.Entries) != 1 {
		return nil, fmt.Errorf("user not found or multiple users found")
	}

	userDN := sr.Entries[0].DN

	// Now try to bind as the user to verify credentials
	userConn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to create user connection: %w", err)
	}
	defer userConn.Close()

	err = userConn.Bind(userDN, password)
	if err != nil {
		return nil, fmt.Errorf("LDAP authentication failed: %w", err)
	}

	// Authentication successful, create client
	client := &Client{
		ID:          0, // Would be generated by database
		Name:        sr.Entries[0].GetAttributeValue("cn"),
		Description: fmt.Sprintf("LDAP user: %s", username),
		Permissions: lm.getUserPermissions(sr.Entries[0]),
		IsActive:    true,
	}

	return client, nil
}

// GetUserGroups retrieves user's groups from LDAP
func (lm *LDAPManager) GetUserGroups(username string) ([]string, error) {
	conn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP: %w", err)
	}
	defer conn.Close()

	// First find the user DN
	userSearch := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.UserFilter, username),
		[]string{"dn"},
		nil,
	)

	userSR, err := conn.Search(userSearch)
	if err != nil {
		return nil, fmt.Errorf("user search failed: %w", err)
	}

	if len(userSR.Entries) != 1 {
		return nil, fmt.Errorf("user not found")
	}

	userDN := userSR.Entries[0].DN

	// Search for groups containing this user
	groupSearch := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.GroupFilter, userDN),
		[]string{"cn"},
		nil,
	)

	groupSR, err := conn.Search(groupSearch)
	if err != nil {
		return nil, fmt.Errorf("group search failed: %w", err)
	}

	var groups []string
	for _, entry := range groupSR.Entries {
		groups = append(groups, entry.GetAttributeValue("cn"))
	}

	return groups, nil
}

// SyncUsers synchronizes users from LDAP (placeholder)
func (lm *LDAPManager) SyncUsers() error {
	// This would sync users from LDAP to local database
	// Implementation depends on specific requirements
	return fmt.Errorf("LDAP user sync not implemented")
}

// connect establishes LDAP connection
func (lm *LDAPManager) connect() (*ldap.Conn, error) {
	address := fmt.Sprintf("%s:%d", lm.config.Host, lm.config.Port)

	var conn *ldap.Conn
	var err error

	if lm.config.TLS {
		conn, err = ldap.DialTLS("tcp", address, &tls.Config{InsecureSkipVerify: true})
	} else {
		conn, err = ldap.Dial("tcp", address)
	}

	if err != nil {
		return nil, err
	}

	// Start TLS if requested
	if lm.config.StartTLS {
		err = conn.StartTLS(&tls.Config{InsecureSkipVerify: true})
		if err != nil {
			conn.Close()
			return nil, err
		}
	}

	// Bind as search user if credentials provided
	if lm.config.BindDN != "" {
		err = conn.Bind(lm.config.BindDN, lm.config.BindPassword)
		if err != nil {
			conn.Close()
			return nil, err
		}
	}

	return conn, nil
}

// getUserPermissions determines permissions based on LDAP groups
func (lm *LDAPManager) getUserPermissions(entry *ldap.Entry) []string {
	groups, err := lm.GetUserGroups(entry.GetAttributeValue("sAMAccountName"))
	if err != nil {
		// Default permissions if group lookup fails
		return []string{"read"}
	}

	var permissions []string

	for _, group := range groups {
		switch strings.ToLower(group) {
		case "llm-admins", "administrators":
			permissions = append(permissions, "admin", "read", "write", "delete")
		case "llm-editors", "editors":
			permissions = append(permissions, "read", "write")
		case "llm-viewers", "viewers":
			permissions = append(permissions, "read")
		}
	}

	// Default to read-only if no groups matched
	if len(permissions) == 0 {
		permissions = []string{"read"}
	}

	return permissions
}

// ValidateConfig validates LDAP configuration
func (lm *LDAPManager) ValidateConfig() error {
	if lm.config.Host == "" {
		return fmt.Errorf("LDAP host is required")
	}
	if lm.config.Port == 0 {
		lm.config.Port = 389 // Default LDAP port
	}
	if lm.config.BaseDN == "" {
		return fmt.Errorf("LDAP base DN is required")
	}
	if lm.config.UserFilter == "" {
		lm.config.UserFilter = "(&(objectClass=user)(sAMAccountName=%s))"
	}

	return nil
}
