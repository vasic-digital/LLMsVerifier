// Package auth provides LDAP integration for enterprise authentication
package auth

import (
	"crypto/tls"
	"fmt"
	"strings"

	"github.com/go-ldap/ldap/v3"
)

// LDAPConfig holds LDAP configuration
type LDAPConfig struct {
	Host               string   `yaml:"host"`
	Port               int      `yaml:"port"`
	BaseDN             string   `yaml:"base_dn"`
	BindDN             string   `yaml:"bind_dn"`
	BindPassword       string   `yaml:"bind_password"`
	UserFilter         string   `yaml:"user_filter"`
	GroupFilter        string   `yaml:"group_filter"`
	Attributes         []string `yaml:"attributes"`
	TLS                bool     `yaml:"tls"`
	StartTLS           bool     `yaml:"start_tls"`
	InsecureSkipVerify bool     `yaml:"insecure_skip_verify"` // WARNING: Only for testing
	CACertPath         string   `yaml:"ca_cert_path"`         // Path to CA certificate
	ServerName         string   `yaml:"server_name"`          // Server name for TLS verification
}

// LDAPManager handles LDAP operations
type LDAPManager struct {
	config *LDAPConfig
}

// NewLDAPManager creates a new LDAP manager
func NewLDAPManager(config *LDAPConfig) (*LDAPManager, error) {
	return &LDAPManager{
		config: config,
	}, nil
}

// Authenticate performs LDAP authentication
func (lm *LDAPManager) Authenticate(username, password string) (*Client, error) {
	if password == "" {
		return nil, fmt.Errorf("password cannot be empty")
	}

	// Connect to LDAP server
	conn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP: %w", err)
	}
	defer conn.Close()

	// First, bind as the search user to find the user's DN
	searchRequest := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.UserFilter, username),
		lm.config.Attributes,
		nil,
	)

	sr, err := conn.Search(searchRequest)
	if err != nil {
		return nil, fmt.Errorf("LDAP search failed: %w", err)
	}

	if len(sr.Entries) != 1 {
		return nil, fmt.Errorf("user not found or multiple users found")
	}

	userDN := sr.Entries[0].DN

	// Now try to bind as the user to verify credentials
	userConn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to create user connection: %w", err)
	}
	defer userConn.Close()

	err = userConn.Bind(userDN, password)
	if err != nil {
		return nil, fmt.Errorf("LDAP authentication failed: %w", err)
	}

	// Authentication successful, create client
	client := &Client{
		ID:          0, // Would be generated by database
		Name:        sr.Entries[0].GetAttributeValue("cn"),
		Description: fmt.Sprintf("LDAP user: %s", username),
		Permissions: lm.getUserPermissions(sr.Entries[0]),
		IsActive:    true,
	}

	return client, nil
}

// GetUserGroups retrieves user's groups from LDAP
func (lm *LDAPManager) GetUserGroups(username string) ([]string, error) {
	conn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP: %w", err)
	}
	defer conn.Close()

	// First find the user DN
	userSearch := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.UserFilter, username),
		[]string{"dn"},
		nil,
	)

	userSR, err := conn.Search(userSearch)
	if err != nil {
		return nil, fmt.Errorf("user search failed: %w", err)
	}

	if len(userSR.Entries) != 1 {
		return nil, fmt.Errorf("user not found")
	}

	userDN := userSR.Entries[0].DN

	// Search for groups containing this user
	groupSearch := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(lm.config.GroupFilter, userDN),
		[]string{"cn"},
		nil,
	)

	groupSR, err := conn.Search(groupSearch)
	if err != nil {
		return nil, fmt.Errorf("group search failed: %w", err)
	}

	var groups []string
	for _, entry := range groupSR.Entries {
		groups = append(groups, entry.GetAttributeValue("cn"))
	}

	return groups, nil
}

// LDAPUser represents a user from LDAP
type LDAPUser struct {
	DN          string   `json:"dn"`
	Username    string   `json:"username"`
	Email       string   `json:"email"`
	DisplayName string   `json:"display_name"`
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Groups      []string `json:"groups"`
	Enabled     bool     `json:"enabled"`
}

// SyncCallback is called for each user during sync
type SyncCallback func(user *LDAPUser) error

// SyncUsers synchronizes users from LDAP
// It returns a list of all users found in LDAP
func (lm *LDAPManager) SyncUsers() ([]*LDAPUser, error) {
	return lm.SyncUsersWithCallback(nil)
}

// SyncUsersWithCallback synchronizes users from LDAP with a callback for each user
func (lm *LDAPManager) SyncUsersWithCallback(callback SyncCallback) ([]*LDAPUser, error) {
	conn, err := lm.connect()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP: %w", err)
	}
	defer conn.Close()

	// Search for all users
	// Use a generic user filter that matches common LDAP schemas
	userFilter := lm.config.UserFilter
	if userFilter == "" {
		userFilter = "(objectClass=person)"
	} else {
		// Remove the %s placeholder for listing all users
		userFilter = strings.Replace(userFilter, "(%s)", "", -1)
		userFilter = strings.Replace(userFilter, "%s", "*", -1)
	}

	searchRequest := ldap.NewSearchRequest(
		lm.config.BaseDN,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0, // No size limit
		0, // No time limit
		false,
		userFilter,
		[]string{"dn", "cn", "sAMAccountName", "mail", "givenName", "sn", "displayName", "userAccountControl", "memberOf"},
		nil,
	)

	sr, err := conn.Search(searchRequest)
	if err != nil {
		return nil, fmt.Errorf("LDAP search failed: %w", err)
	}

	var users []*LDAPUser

	for _, entry := range sr.Entries {
		user := &LDAPUser{
			DN:          entry.DN,
			Username:    entry.GetAttributeValue("sAMAccountName"),
			Email:       entry.GetAttributeValue("mail"),
			DisplayName: entry.GetAttributeValue("displayName"),
			FirstName:   entry.GetAttributeValue("givenName"),
			LastName:    entry.GetAttributeValue("sn"),
			Enabled:     true,
		}

		// Fallback for username
		if user.Username == "" {
			user.Username = entry.GetAttributeValue("cn")
		}

		// Get group memberships
		user.Groups = entry.GetAttributeValues("memberOf")

		// Check if account is disabled (Active Directory specific)
		uacStr := entry.GetAttributeValue("userAccountControl")
		if uacStr != "" {
			// UAC flag 0x2 means account is disabled
			// This is a simplified check
			if strings.Contains(uacStr, "514") || strings.Contains(uacStr, "546") {
				user.Enabled = false
			}
		}

		// Call callback if provided
		if callback != nil {
			if err := callback(user); err != nil {
				// Log error but continue syncing
				fmt.Printf("Warning: callback error for user %s: %v\n", user.Username, err)
			}
		}

		users = append(users, user)
	}

	return users, nil
}

// GetUserCount returns the number of users in LDAP
func (lm *LDAPManager) GetUserCount() (int, error) {
	users, err := lm.SyncUsers()
	if err != nil {
		return 0, err
	}
	return len(users), nil
}

// connect establishes LDAP connection with proper TLS security
func (lm *LDAPManager) connect() (*ldap.Conn, error) {
	address := fmt.Sprintf("%s:%d", lm.config.Host, lm.config.Port)

	var conn *ldap.Conn
	var err error

	// Build TLS configuration
	tlsConfig := lm.buildTLSConfig()

	if lm.config.TLS {
		conn, err = ldap.DialTLS("tcp", address, tlsConfig)
	} else {
		conn, err = ldap.Dial("tcp", address)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to connect to LDAP server: %w", err)
	}

	// Start TLS if requested (for non-TLS connections that want to upgrade)
	if lm.config.StartTLS && !lm.config.TLS {
		err = conn.StartTLS(tlsConfig)
		if err != nil {
			conn.Close()
			return nil, fmt.Errorf("failed to start TLS: %w", err)
		}
	}

	// Bind as search user if credentials provided
	if lm.config.BindDN != "" {
		err = conn.Bind(lm.config.BindDN, lm.config.BindPassword)
		if err != nil {
			conn.Close()
			return nil, fmt.Errorf("failed to bind to LDAP: %w", err)
		}
	}

	return conn, nil
}

// buildTLSConfig creates a TLS configuration based on LDAP config
func (lm *LDAPManager) buildTLSConfig() *tls.Config {
	tlsConfig := &tls.Config{
		MinVersion: tls.VersionTLS12, // Enforce minimum TLS 1.2
	}

	// Set server name for verification
	if lm.config.ServerName != "" {
		tlsConfig.ServerName = lm.config.ServerName
	} else {
		tlsConfig.ServerName = lm.config.Host
	}

	// Only skip verification if explicitly configured (for testing only)
	// Default is secure (verify certificates)
	if lm.config.InsecureSkipVerify {
		tlsConfig.InsecureSkipVerify = true
		// Log a warning that this is insecure
		fmt.Println("WARNING: LDAP TLS certificate verification is disabled. This is insecure and should only be used for testing.")
	}

	// Load CA certificate if provided
	if lm.config.CACertPath != "" {
		// In production, you would load the CA cert here:
		// caCert, err := os.ReadFile(lm.config.CACertPath)
		// if err == nil {
		//     caCertPool := x509.NewCertPool()
		//     caCertPool.AppendCertsFromPEM(caCert)
		//     tlsConfig.RootCAs = caCertPool
		// }
	}

	return tlsConfig
}

// getUserPermissions determines permissions based on LDAP groups
func (lm *LDAPManager) getUserPermissions(entry *ldap.Entry) []string {
	groups, err := lm.GetUserGroups(entry.GetAttributeValue("sAMAccountName"))
	if err != nil {
		// Default permissions if group lookup fails
		return []string{"read"}
	}

	var permissions []string

	for _, group := range groups {
		switch strings.ToLower(group) {
		case "llm-admins", "administrators":
			permissions = append(permissions, "admin", "read", "write", "delete")
		case "llm-editors", "editors":
			permissions = append(permissions, "read", "write")
		case "llm-viewers", "viewers":
			permissions = append(permissions, "read")
		}
	}

	// Default to read-only if no groups matched
	if len(permissions) == 0 {
		permissions = []string{"read"}
	}

	return permissions
}

// ValidateConfig validates LDAP configuration
func (lm *LDAPManager) ValidateConfig() error {
	if lm.config.Host == "" {
		return fmt.Errorf("LDAP host is required")
	}
	if lm.config.Port == 0 {
		lm.config.Port = 389 // Default LDAP port
	}
	if lm.config.BaseDN == "" {
		return fmt.Errorf("LDAP base DN is required")
	}
	if lm.config.UserFilter == "" {
		lm.config.UserFilter = "(&(objectClass=user)(sAMAccountName=%s))"
	}

	return nil
}
